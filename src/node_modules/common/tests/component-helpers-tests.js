import most from 'most';
import {assert} from 'chai';
import {internals, partitionComponents, mergeSinks, consolidateChildren} from '../component-helpers';
import util from 'util';

/*eslint-disable no-unused-vars */
let startDate = Date.now();
const timeSig = () => Date.now() - startDate;
const run = fn => new Promise(resolve => resolve(fn()));
const $ = arr => ((arr.isStream = true), arr);
const make$ = (arr, t) => most.periodic(t||10, 1).zip((t, x) => x, most.from(arr));
const inspect = (...args) => console.log.bind(console, `[${timeSig()}ms]`)(...args.map(arg => util.inspect(arg, false, 10, true)));
/*eslint-enable */

function deepCapture(source) {
  return run(() => {
    if(source instanceof Array) return Promise.all(source.map(deepCapture));
    if(source instanceof most.Stream) return source
       .reduce((acc, x) => (acc.push(Promise.resolve(deepCapture(x))), acc), [])
       .then(arr => Promise.all(arr).then($));
    return source;
  });
}

describe('app', () => {
  startDate = Date.now();
  describe('#partitionComponents()', () => {

    it('should return an object with the properties `streams` and `statics`', () => {
      const result = partitionComponents({});
      assert.property(result, 'streams');
      assert.property(result, 'statics');
      assert.isArray(result.streams);
      assert.isArray(result.statics);
    });

    it('should return partition plain objects into `statics` and streams into `streams`', () => {
      const result = partitionComponents({
        a: {x:1},
        b: most.just(1),
        c: most.just(2),
        d: {y:2},
        e: {z:3},
      });

      assert.lengthOf(result.statics, 3);
      assert.equal('a', result.statics[0].key);
      assert.equal('d', result.statics[1].key);
      assert.equal('e', result.statics[2].key);
      assert.deepEqual({x:1}, result.statics[0].sinks);
      assert.deepEqual({y:2}, result.statics[1].sinks);
      assert.deepEqual({z:3}, result.statics[2].sinks);

      assert.lengthOf(result.streams, 2);
      assert.equal('b', result.streams[0].key);
      assert.equal('c', result.streams[1].key);
      assert.equal(1, result.streams[0].sinks$.source.value);
      assert.equal(2, result.streams[1].sinks$.source.value);
    });
  });

  describe('#projectSinkFromComponentStream()', () => {

    it('should extract a stream of the values for the specified sink key', () => {
      const sinks$ = most.from([
        { foo: most.from([1, 2]), bar: most.from([10, 11]) },
        { foo: most.from([4, 5]), bar: most.from([13, 14]) },
        { foo: most.from([7, 8]), bar: most.from([16, 17]) }
      ]);
      const foo$ = internals.projectSinkFromComponentStream('foo', sinks$);
      assert.instanceOf(foo$, most.Stream);
      return deepCapture(foo$)
        .then(result => {
          const expected = $([7, 8]);
          assert.deepEqual(result, expected);
        });
    });
  });

  describe('#mergeSinks()', () => {

    const sinks = {
      a: {
        x: most.from([1, 2]),
        y: most.from([3, 4]),
        z: most.from([5, 6])
      },
      b: {
        x: most.from([10, 11]),
        y: most.from([12, 13]),
        z: most.from([14, 15])
      },
      c: most.from([
        {
          x: most.from([20, 21]),
          y: most.from([22, 23]),
          z: most.from([24, 25]),
        },
        {
          x: most.from([30, 31]),
          z: most.from([32, 33]),
        },
        {
          y: most.from([34, 35]),
        }
      ]),
      d: most.from([
        {
          y: most.from([220, 230]),
          z: most.from([240, 250]),
        },
        {
          x: most.from([500, 501]),
          a: most.from([502, 503]),
          k: most.from([504, 505]),
        }
      ])
    };
    const partitioned = partitionComponents(sinks);
    const merged = mergeSinks(['x', 'y'], partitioned);

    it('should merge the specified sinks from multiple components into a single set of output sinks', () => {
      assert.isObject(merged);
      assert.property(merged, 'x');
      assert.property(merged, 'y');
      assert.notProperty(merged, 'z');
      assert.notProperty(merged, 'k');
      assert.notProperty(merged, 'a');
      assert.instanceOf(merged.x, most.Stream);
      assert.instanceOf(merged.y, most.Stream);
    });

    it('should yield the set of values from each of the merged streams', () => {
      return deepCapture(merged.x)
        .then(result => {
          assert.deepEqual(result, $([1, 2, 10, 11, 30, 31, 500, 501]));
          return deepCapture(merged.y);
        })
        .then(result => {
          assert.deepEqual(result, $([3, 4, 12, 13, 34, 35, 220, 230]));
        });
    });
  });

  describe('#buildStateStream()', () => {
    const sinks = {
      d: make$([
          { state: make$([
            { x: 10, y: 11 }, // immediate
            { x: 12, y: 13 }  // 70ms
          ], 70)},
          { state: make$([
            { x: 14, y: 15 }, // 50ms
            { x: 16, y: 17 } // 60ms
          ])}
        ], 50),
      e: make$([
          { state: make$([{ y: 18 }]) }, // immediate
          { state: make$([{ y: 19 }]) } // 10ms
        ]),
      a: { state: make$([
          { x: 1, y: 2 }, // immediate
          { x: 3, y: 4 }, // 30ms
          { x: 3.5, y: 4.5 }
        ], 30)},
      b: { state: make$([
          { x: 5, y: 6 }, // immediate
          { x: 7, y: 8 } // 10ms
        ])},
      c: {} // immediate
    };
    const partitioned = partitionComponents(sinks);

    it('buildPairStreamArray() should return an array of streams of key/state objects', () => {
      const pair$arr = internals.buildPairStreamArray(partitioned.statics);
      return deepCapture(pair$arr)
        .then(result => {
          const expected = [
            $([{ key: 'a', state: { x: 1, y: 2 }}, { key: 'a', state: { x: 3, y: 4 }}, { key: 'a', state: { x: 3.5, y: 4.5 }}]),
            $([{ key: 'b', state: { x: 5, y: 6 }}, { key: 'b', state: { x: 7, y: 8 }}]),
            $([{ key: 'c', state: { }}])
          ];
          assert.deepEqual(result, expected);
        });
    });

    it('buildHigherOrderPairStreamArray() should return an array of higher-order streams of key/state pairs', () => {
      const pair$$arr = internals.buildHigherOrderPairStreamArray(partitioned.streams);
      return deepCapture(pair$$arr)
        .then(result => {
          const expected = [
            $([
              $([{ key: 'd', state: { x:10, y:11 }}, { key: 'd', state: { x:12, y:13 }}]),
              $([{ key: 'd', state: { x:14, y:15 }}, { key: 'd', state: { x:16, y:17 }}])
            ]),
            $([
              $([{ key: 'e', state: { y: 18 }}]),
              $([{ key: 'e', state: { y: 19 }}])
            ])
          ];
          assert.deepEqual(result, expected);
        });
    });

    it('makeChannelPerSinkKey() should combine pair$arr and pair$$arr into a single array of pair streams', () => {
      const pair$arr = internals.buildPairStreamArray(partitioned.statics);
      const pair$$arr = internals.buildHigherOrderPairStreamArray(partitioned.streams);
      const channels = internals.makeChannelPerSinkKey(pair$$arr, pair$arr);
      function makePairStream(key, ...states) { return states.map(state => ({ key, state })); }
      function fn(key) { return makePairStream.bind(null, key); }
      const a = fn('a'), b = fn('b'), c = fn('c'), d = fn('d'), e = fn('e');
      return deepCapture(channels)
        .then(result => {
          const expected = [
            $(d({ x: 10, y: 11 }, { x: 14, y: 15 }, { x: 16, y: 17 })),
            $(e({ y: 18 }, { y: 19 })),
            $(a({ x: 1, y: 2 }, { x: 3, y: 4 }, { x: 3.5, y: 4.5 })),
            $(b({ x: 5, y: 6 }, { x: 7, y: 8 })),
            $(c({}))
          ];
          assert.deepEqual(result, expected);
        });
    });

    it('buildStateStreamFromChannels() should return a stream of state objects assembled from the underlying channels', () => {
      const pair$arr = internals.buildPairStreamArray(partitioned.statics);
      const pair$$arr = internals.buildHigherOrderPairStreamArray(partitioned.streams);
      const channels = internals.makeChannelPerSinkKey(pair$$arr, pair$arr);
      const state$ = internals.buildStateStreamFromChannels(channels);
      return deepCapture(state$)
        .then(result => {
          const expected = $([
            {
              a: { x: 1, y: 2 },
              b: { x: 5, y: 6 },
              c: {},
              d: { x: 10, y: 11 },
              e: { y: 18 }
            }, {
              a: { x: 1, y: 2 },
              b: { x: 7, y: 8 },
              c: {},
              d: { x: 10, y: 11 },
              e: { y: 18 }
            }, {
              a: { x: 1, y: 2 },
              b: { x: 7, y: 8 },
              c: {},
              d: { x: 10, y: 11 },
              e: { y: 19 }
            }, {
              a: { x: 3, y: 4 },
              b: { x: 7, y: 8 },
              c: {},
              d: { x: 10, y: 11 },
              e: { y: 19 }
            }, {
              a: { x: 3, y: 4 },
              b: { x: 7, y: 8 },
              c: {},
              d: { x: 14, y: 15 },
              e: { y: 19 }
            }, {
              a: { x: 3.5, y: 4.5 },
              b: { x: 7, y: 8 },
              c: {},
              d: { x: 14, y: 15 },
              e: { y: 19 }
            }, {
              a: { x: 3.5, y: 4.5 },
              b: { x: 7, y: 8 },
              c: {},
              d: { x: 16, y: 17 },
              e: { y: 19 }
            }
          ]);
          assert.lengthOf(result, 7);
          assert.deepEqual(result, expected);
        });
    });

    it('buildStateStreamFromChannels() should should still work if there are only streams of sinks', () => {
      const partitioned = partitionComponents({ d: sinks.d, e: sinks.e });
      const pair$arr = internals.buildPairStreamArray(partitioned.statics);
      const pair$$arr = internals.buildHigherOrderPairStreamArray(partitioned.streams);
      const channels = internals.makeChannelPerSinkKey(pair$$arr, pair$arr);
      const state$ = internals.buildStateStreamFromChannels(channels);
      return deepCapture(state$)
        .then(result => {
          const expected = $([
            {
              d: { x: 10, y: 11 },
              e: { y: 18 }
            }, {
              d: { x: 10, y: 11 },
              e: { y: 19 }
            }, {
              d: { x: 14, y: 15 },
              e: { y: 19 }
            }, {
              d: { x: 16, y: 17 },
              e: { y: 19 }
            }
          ]);
          assert.lengthOf(result, 4);
          assert.deepEqual(result, expected);
        });
    });

    it('buildStateStreamFromChannels() should should still work if there are only static sinks', () => {
      const partitioned = partitionComponents({ a: sinks.a, b: sinks.b, c: sinks.c });
      const pair$arr = internals.buildPairStreamArray(partitioned.statics);
      const pair$$arr = internals.buildHigherOrderPairStreamArray(partitioned.streams);
      const channels = internals.makeChannelPerSinkKey(pair$$arr, pair$arr);
      const state$ = internals.buildStateStreamFromChannels(channels);
      return deepCapture(state$)
        .then(result => {
          const expected = $([
            {
              a: { x: 1, y: 2 },
              b: { x: 5, y: 6 },
              c: {}
            }, {
              a: { x: 1, y: 2 },
              b: { x: 7, y: 8 },
              c: {}
            }, {
              a: { x: 3, y: 4 },
              b: { x: 7, y: 8 },
              c: {}
            }, {
              a: { x: 3.5, y: 4.5 },
              b: { x: 7, y: 8 },
              c: {}
            }
          ]);
          assert.lengthOf(result, 4);
          assert.deepEqual(result, expected);
        });
    });
  });

  describe('#consolidateChildren()', () => {

    it('should return an object of { sinks, state$ }', () => {
      const sinks = {};
      const result = consolidateChildren(sinks, ['a', 'b']);
      assert.property(result, 'sinks');
      assert.property(result, 'state$');
      assert.isObject(result.sinks);
      assert.property(result.sinks, 'a');
      assert.property(result.sinks, 'b');
      assert.instanceOf(result.state$, most.Stream);
    });

  });

});
