import most from 'most';
import isolate from '@cycle/isolate';
import {assign, isPlainObject, identity} from './utils';
import {applyRouter} from './routing-helpers';

export function partitionComponents(components) {
  return Array.from(Object.keys(components))
    .reduce((acc, key) =>
      (((components[key] instanceof most.Stream && acc.streams.push({ key, sinks$: components[key] })) ||
      (isPlainObject(components[key]) && acc.statics.push({ key, sinks: components[key] }))), acc),
    { streams:[], statics:[] });
}

function projectSinkFromComponentStream(key, sinks$) {
  return sinks$
    .filter(sinks => sinks[key] && sinks[key] instanceof most.Stream)
    .map(sinks => sinks[key])
    .switch();
}

/** Merges the specified sinks from multiple components into a single set of output sinks */
export function mergeSinks(sinkKeys, { streams, statics }) {
  return sinkKeys.reduce((sinks, key) => {
    const a = streams.map(component => projectSinkFromComponentStream(key, component.sinks$));
    const b = statics.map(component => component.sinks[key]).filter(identity);
    sinks[key] = most.mergeArray(a.concat(b));
    return sinks;
  }, {});
}

function stateFromSinks(sinks) {
  const state$ = sinks.DOM
    ? sinks.state
      ? sinks.state.combine((state, vtree) => assign(state, { vtree }), sinks.DOM)
      : sinks.DOM.map(vtree => ({ vtree }))
    : sinks.state || most.just({});
  return state$;
}

function buildPairStreamArray(statics) {
  /*
  @param statics: [{ key, sinks }, ...]
  where sinks:    { state, ... } // state is a stream of plain state objects; '...' indicates other discarded sinks
  @returns:       [pair$, ...]
  where pair:     { key, state }
  */
  return statics.map(({ key, sinks }) => stateFromSinks(sinks).map(state => ({ key, state })));
}

function buildHigherOrderPairStreamArray(streams) {
  /*
  @param streams: [{ key, sinks$ }, ...]
  @returns:       [pair$$, ...]
  where pair:     { key, state }
  */
  const makePair = (key, state) => ({ key, state });
  const pair$FromSinks = (key, sinks) => stateFromSinks(sinks).map(state => makePair(key, state));
  const pair$$FromBasePair = ({ key, sinks$ }) => sinks$.map(sinks => pair$FromSinks(key, sinks));
  const pair$$arr = streams.map(pair$$FromBasePair);
  return pair$$arr;
}

function makeChannelPerSinkKey(pair$$arr, pair$arr) {
  return pair$$arr.map(pair$$ => pair$$.switch()).concat(pair$arr);
}

function buildStateStreamFromChannels(channels) {
  /*
  @param channels: [pair$, ...]
  @returns stream: | state, state, ..., -->
  */
  return most
    .combineArray((...pairs) => pairs, channels)
    .map(pairs => pairs.sort((a,b) => a.key.localeCompare(b.key))
                       .reduce((acc, pair) => ((acc[pair.key] = pair.state), acc), {}));
}

export function buildStateStream({ streams, statics }) {
  const pair$arr = buildPairStreamArray(statics);
  const pair$$arr = buildHigherOrderPairStreamArray(streams);
  const channels = makeChannelPerSinkKey(pair$$arr, pair$arr);
  return buildStateStreamFromChannels(channels);
}

export var internals = {
  stateFromSinks,
  projectSinkFromComponentStream,
  buildPairStreamArray,
  buildHigherOrderPairStreamArray,
  makeChannelPerSinkKey,
  buildStateStreamFromChannels
};

export function consolidateChildren(components, keysToMerge, fnCreateRepresentation) {
  // Pending requests from children (such as http calls, etc.) need to be passed to output sinks.
  // Some children will be streams of component sinks, whereas others will be static sets of sinks.
  const partitioned = partitionComponents(components);
  const sinks = keysToMerge ? mergeSinks(keysToMerge, partitioned) : {};
  const state$ = buildStateStream(partitioned);
  return { sinks, state$ };
}

export function collapseStateToModel(state) {
  const newState = {};
  for(let key in state) {
    const value = state[key];
    if(!isPlainObject(value)) {
      continue;
    }
    if('model' in value) {
      newState[key] = value.model;
    }
  }
  return newState;
}

function makePageSink(routeApplied$) {
  return routeApplied$
    .map(r => assign(r.sinks, {
      state: r.sinks.state.map(state => assign(state, { route: r.route }))
    }));
}

function makeNewPageState(makeState, state) {
  const newState = makeState(state);
  return newState;
}

export function makePageComponent({ routes, makeView, makeModel, main }) {
  return isolate(function PageComponent(sources) {
    const makeState = sources.state.makeFactory(makeView, makeModel);
    let components;
    if(routes) {
      const routeApplied$ = applyRouter(sources, routes); // => stream of { route, sinks }
      const page$ = makePageSink(routeApplied$);
      components = assign({ page: page$ }, main ? main(assign(sources, { page$ })) : {});
    }
    else if(main) {
      components = main(sources);
    }
    if(components) {
      const merged = consolidateChildren(components);
      const state$ = merged.state$.map(state => makeNewPageState(makeState, state));
      return assign(merged.sinks, { state: state$ });
    }
    return { state: most.just(makeNewPageState(makeState, {})) };
  });
}
