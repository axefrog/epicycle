import util from 'util';

export function inspect(...args) {
  if(process.browser)
    console.log(...args);
  else {
    console.log(...args.map(arg => util.inspect(arg, false, 10, true)));
  }
}

export function debug(...args) {
  const defaultArgs = args.slice(1);
  if(typeof args[0] !== 'function') {
    throw new Error('debug() must take a function as the first argument, followed by zero or more optional parameters to be logged to the console.');
  }
  return (...moreArgs) => {
    inspect(...defaultArgs, '[INPUTS]', ...moreArgs);
    const value = args[0](...moreArgs);
    inspect(...defaultArgs, '[OUTPUT]', value);
    return value;
  };
}

export function logError(e) {
  console.error('ERROR:', e.message || e);
  if(e.stack) {
    console.error(e.stack);
  }
}

export function assign() {
  return Object.assign({}, ...arguments);
}

export function isPlainObject(obj) {
  return obj && typeof obj === 'object' && obj.constructor === Object.prototype.constructor;
}

export function identity(x) {
  return x;
}

export function bind(fn, ...args) {
  return fn.bind(null, ...args);
}

export function curry(f) {
  // credit to: https://gist.github.com/djtriptych/7260910a5b32a572cfad
  return function () {
    var args = Array.prototype.slice.call(arguments, 0);
    return args.length < f.length
      ? curry(args.reduce(function(g, arg) { return g.bind(null, arg); }, f))
      : f.apply(null, args);
  };
}

export function pick(properties, obj) {
  const value = {};
  for(let key of properties) {
    if(key in obj) {
      value[key] = obj[key];
    }
  }
  return value;
}

export function omit(properties, obj) {
  const value = {};
  const set = new Set(properties);
  for(let key in obj) {
    if(!set.has(key)) {
      value[key] = obj[key];
    }
  }
  return value;
}

export function prune(options, obj) {
  if(!isPlainObject(obj)) {
    return obj;
  }
  if(options instanceof Array) {
    options = { properties: options };
  }
  const invert = !!options.invert;
  const replaceWith = 'replaceWith' in options ? options.replaceWith : void 0;
  const replacementExists = replaceWith !== void 0;
  const set = new Set(options.properties);
  let it;
  const stack = [[obj, {}, (it = Object.keys(obj).entries()), it.next()]];
  while(true) {
    const layer = stack[stack.length - 1];
    let [src, dest, it, current] = layer;
    if(current.done) {
      stack.pop();
      if(stack.length === 0) {
        return dest;
      }
      continue;
    }
    let key = current.value[1];
    layer[3] = it.next();
    const shouldPrune = set.has(key) !== invert;
    if(shouldPrune) {
      if(replacementExists) {
        dest[key] = replaceWith;
      }
    }
    else {
      const value = src[key];
      if(isPlainObject(value)) {
        const newValue = dest[key] = {};
        dest = newValue;
        stack.push([value, dest, (it = Object.keys(value).entries()), it.next()]);
        continue;
      }
      else {
        dest[key] = value;
      }
    }
  }
}

// temporary; for diagnostic purposes only.
export const lookat = (...args) => inspect(...args.slice(0, args.length-1), prune({ properties: ['vtree'], replaceWith: '?' }, args[args.length-1]));

function merge2(a, b) {
  for(let key in b) {
    const source = b[key];
    const target = a[key];
    if(isPlainObject(target) && isPlainObject(source)) {
      a[key] = merge2(target, source);
    }
    else if(source === void 0) {
      delete a[key];
    }
    else {
      a[key] = b[key];
    }
  }
  return a;
}

/** Merges the properties of each argument into the one before it. Deep merging
  * is applied only where both the source and target properties are plain
  * JavaScript objects (constructor must be Object). Arrays are not merged.
  */
export function deepMerge() {
  if(arguments.length <= 1) {
    return arguments[0];
  }
  let source = arguments[arguments.length - 1];
  for(let i = arguments.length - 2; i >= 0; i--) {
    let target = arguments[i];
    source = merge2(target, source);
  }
  return source;
}
